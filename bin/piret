#!/usr/bin/env python

"""
RNA seq pipeline.

wrapper for running RNASeq pipeline

"""

import os
import sys
import argparse
import luigi
import logging
import configparser
dir_path = os.path.dirname(os.path.realpath(__file__))
lib_path = os.path.abspath(os.path.join(dir_path, '..'))
bin_path = os.path.join(lib_path, 'bin')
script_path = os.path.join(lib_path, 'scripts')
sys.path.append(lib_path)
sys.path.append(script_path)
os.environ["PATH"] += os.pathsep + bin_path
os.environ["PATH"] += os.pathsep + script_path
from piret.checks import CheckDesign, CheckDependencies
from piret.checks.Dependencies import check_depen
from piret.Runs import Map, srna
from piret.Workflows import DualSeq, SingleSeq
from piret.checks.GFF3 import CheckGFF
from piret.checks.aligner import check_aligner
from piret.checks.config import parse_config, check_input
from piret.logger import create_logger
from luigi.interface import build


def cmdline_parser():
    """
    Create an argparse instance.

    Combination of different options for this script.
    """
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                          argparse.RawDescriptionHelpFormatter):
        """For multiple formatters of argparse."""

        pass

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     prog='piret',
                                     description="""piret""",
                                     epilog="""
Example runs:\n
        piret -d <workdir> -e <design file>  -c <config file>
        """)

    required_args = parser.add_argument_group('required arguments')

    required_args.add_argument("-d", dest="WORKDIR", help="""working directory where all
        output files will be processed and written""", required=True)

    required_args.add_argument("-e", dest="EXPDSN", help="""tab delimited experimental
        design file""", required=True, default=argparse.SUPPRESS)

    required_args.add_argument("-c", "--config", help="""luigi config file for setting
        parameters that control each step, see github repo for an example""", required=True, default=None)

    parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.3.4')

    return parser


def main():
    """
    Main function.

    All functions are called here.
    """
    parser = cmdline_parser()
    args = parser.parse_args()

    #TODO: figure out why this is not working
    os.environ["LUIGI_CONFIG_PATH"] = args.config

    # setting up logging files
    logger = create_logger(args.WORKDIR)

    # get parameters from the config file
    paras = parse_config(args.config)

    # check if correct options are selected
    check_input(paras, parser=parser)

    # check if required third party tools are in path
    if paras["aligner"] == "STAR":
        check_depen(["STAR", "samtools"], logger)
    elif paras["aligner"] == "hisat2":
        check_depen(["hisat2", "samtools"], logger)

    # getting absolute path of workdir
    workdir = os.path.abspath(args.WORKDIR)

    if check_exp_design(args.EXPDSN) is False:  # check if experimental design file is OK
        sys.exit("Your experimental design file has formatting problems!")

    # convert exerimental design file to a dictionary object
    samp_dic = CheckDesign(args.EXPDSN).extract_sample_fastqs()

    no_of_jobs = 1

    # assigns filenames for databases if not specified.
    db = check_aligner(aligner=paras["aligner"],
                       hisat_index=paras["hisat_index"],
                       workdir=workdir, star_db=paras["star_index"])

    # TODO move this to log file
    summarize_run(aligner=paras["aligner"])  # print run information in screen

    # assign universal fasta and gff variable
    if paras["kingdom"] in ["prokarya", "eukarya"]:
        if paras["kingdom"] == "prokarya":
            fasta = paras["fasta_prok"]
            gff = paras["gff_prok"]
        elif paras["kingdom"] == "eukarya":
            fasta = paras["fasta_euk"]
            gff = paras["gff_euk"]
        single_seq = SingleSeq(qc=paras["qc"],
                                fastq_dic=samp_dic,
                            aligner=paras["aligner"],
                            ref_fasta=fasta,
                            num_cpus=paras["threads"],
                            local_scheduler=True,
                            hisat_index=db,
                            workdir=workdir,
                            kingdom=paras["kingdom"],
                            no_of_jobs=no_of_jobs,
                            p_value=paras["q_value"],
                            exp_desn_file=args.EXPDSN,
                            stardb_dir=db,
                            gff_file=gff,
                            pathway=paras["pathway"])

        # step 1, run qc
        qc_dic = single_seq.run_faqc()

        # step 2, create database, hisat2 or stardb
        single_seq.create_db()

        # step 3, map reads, hisat2 or stardb
        single_seq.map_reads(qc_dic=qc_dic)

        # step 4, summarize the mapped reads
        single_seq.map_summarize()

        # step 5, if needed
        if paras["novel"] is True:  # if novel regions are to be reported
            single_seq.extract_pp()  # extract properly paired reads
            single_seq.NovelRegions()  # find novel regions
            single_seq.create_new_gff()  # create a new GFF file that has novel region info
            gff = os.path.join(workdir, "processes", "novel", "updated.gff")  # update gff
        # step 6, run read counts
        single_seq.feature_count(new_gff=gff)
        single_seq.merge_stringtie(new_gff=gff)



        # find diff expressed gene using edgeR
        if "edgeR" in paras["method"]:
            single_seq.run_edger()
        # use DESeq2
        if "DESeq2" in paras["method"]:
            single_seq.run_deseq2()
        if "ballgown" in paras["method"]:
            print("migungown")
            single_seq.restringtie()
            single_seq.run_ballgown()

        # run opaver pathway analysis
        if paras["pathway"] is True:
            # run emapper
            single_seq.run_emapper(new_gff=gff)
            # if "edgeR" in paras["method"]:
            #     single_seq.run_opaver(method="edgeR")
            # if "DESeq2" in paras["method"]:
            #     single_seq.run_opaver(method="DESeq2")

        # summarize all results into one big json file.
        single_seq.summ_json(new_gff=gff, method=paras["method"],
                             NovelRegions=paras["novel"])

    # if args.TEST_KINGDOM == 'both' and args.qsub is False:
    #     check_ref(ref_gff=args.GFF_EUK, ref_fasta=args.FASTA_EUK)
    #     check_ref(ref_gff=args.GFF_PROK, ref_fasta=args.FASTA_PROK)
    #     fastas = ",".join([args.FASTA_PROK, args.FASTA_EUK])
    #     gffs = ",".join([args.GFF_PROK, args.GFF_EUK])
    #     if check_method(args.METHOD, args.EXPDSN) is True:
    #         run_faqc(fastq_dic=samp_dic, num_cpus=args.CPU, workdir=workdir,
    #                  local_scheduler=args.scheduler)
    #     dual_seq = Workflows.DualSeq(fastq_dic=samp_dic, ref_fastas=fastas,
    #                                  aligner=args.ALIGNER,
    #                                  hisat_index=db,
    #                                  workdir=workdir,
    #                                  kingdom=args.TEST_KINGDOM,
    #                                  no_of_jobs=1,
    #                                  local_scheduler=args.scheduler,
    #                                  num_cpus=args.CPU,
    #                                  exp_desn_file=args.EXPDSN,
    #                                  p_value=args.P_VALUE,
    #                                  ref_gffs=gffs,  # gff of both,
    #                                  stardb_dir=db
    #                                  )

    #     dual_seq.create_db(gffs) # create database (star or hisat2 based on choice)
    #     dual_seq.map_reads()
    #     dual_seq.map_summarize()
    #     dual_seq.split_prokeuk()
    #     if args.NOVEL is True: # if novel regions are to be reported
    #         dual_seq.extract_pp() # extract properly paired reads
    #         dual_seq.NovelRegions() # find novel regions
    #         dual_seq.create_new_gff() # create a new GFF file that has novel region info
    #         gffs = ",".join([os.path.join(workdir, "prok_updated.gff"), os.path.join(workdir, "euk_updated.gff")]) # update gff
    #     dual_seq.feature_counts()
    #     if args.METHOD == "edgeR":
    #         dual_seq.run_edger()
    #     elif args.METHOD == "DESeq2":
    #         dual_seq.run_deseq2()
    #     elif args.METHOD == "ballgown":
    #         dual_seq.merge_stringties()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "DEedge":
    #         dual_seq.run_edger()
    #         dual_seq.run_deseq2()
    #     elif args.METHOD == "DEgown":
    #         dual_seq.run_deseq2()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "balledgeR":
    #         dual_seq.run_edger()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "all":
    #         dual_seq.run_edger()
    #         dual_seq.run_deseq2()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()


def check_exp_design(exp_design_file):
    """A function that checks different aspects of experimental des. file.

    it returns True if all checked conditions are True. This is the first step
    of the pipeline.
    """
    exp_desn = CheckDesign(exp_design_file)
    if all([exp_desn.tab(),
            exp_desn.header(),
            exp_desn.sample_name(),
            exp_desn.file_name(),
            exp_desn.group_name(),
            exp_desn.sample_name(),
            exp_desn.fastq_exists()]) is True:
        return True


def check_gff(gff_file):
    """A function that checks gff file.

    it returns True if all checked conditions are True. This is one of
    the first stepof the pipeline.
    """
    gff = CheckGFF(gff_file)
    if all([gff.size(), gff.check_id(), gff.check_unique_id()]) is True:
        return True
    else:
        return False

def check_index_file(indexfile):
    """Check if index file is present."""
    hisat_file = indexfile + '.6.ht2l'
    if os.path.exists(hisat_file):
        return True
    else:
        return False


def check_star_aligner(method, kingdom):
    """Only allow STAR aligner to work for eukarya only."""
    if method in ('STAR') and kingdom == "prokarya":
        sys.exit("STAR does not work well for prokaryotic genomes, pick hisat2!")
    else:
        return True

def check_method(method, exp_design_file):
    """Based on chosen method, if enough samples are present."""
    exp_desn = CheckDesign(exp_design_file)
    if method in ('DESeq2', 'all', 'DEgown', 'DEedge') and exp_desn.sample_suff(method='Deseq'):
        return True
    elif method in ('edgeR', 'ballgown', 'balledgeR'):
        return True
    else:
        sys.exit("DESeq2 requires at least three replicates within a group!")


def check_ref(ref_fasta=None, ref_gff=None):
    """Check if references are present."""
    if ',' in ref_fasta:
        if all([os.path.exists(f) for f in ref_fasta.split(",")]) is True:
            pass
        else:
            sys.exit("One of the reference fasta do not exist!")
    if ',' in ref_gff:
        if all([os.path.exists(f) for f in ref_gff.split(",")]) is True:
            return True
        else:
            sys.exit("One of the reference gff do not exist!")
    else:
        if os.path.exists(ref_gff) and os.path.exists(ref_fasta):
            if check_gff(ref_gff) is True:
                return True
        else:
            if os.path.exists(ref_fasta) is False:
                exit_message = ' '.join(("Reference FASTA", ref_fasta, "does not exist!"))
                sys.exit(exit_message)
            elif os.path.exists(ref_gff) is False:
                exit_message = ' '.join(("Reference GFF", ref_gff, "does not exist!"))


def summarize_run(aligner):
    """Prints summary information of runs."""
    print("Alignment will be done using: %s" %aligner)


if __name__ == '__main__':
    main()
