#!/usr/bin/env python

"""
RNA seq pipeline.

wrapper for running RNASeq pipeline

"""

import os
import sys
import argparse
import luigi
import logging
import configparser
dir_path = os.path.dirname(os.path.realpath(__file__))
lib_path = os.path.abspath(os.path.join(dir_path, '..'))
bin_path = os.path.join(lib_path, 'bin')
script_path = os.path.join(lib_path, 'scripts')
sys.path.append(lib_path)
sys.path.append(script_path)
os.environ["PATH"] += os.pathsep + bin_path
os.environ["PATH"] += os.pathsep + script_path
from piret.Checks import CheckDesign, CheckDependencies
from piret.Checks.Dependencies import check_depen
from piret.Runs import FaQC, Map, Summ, DGE, srna
from piret.Workflows import DualSeq, SingleSeq
from piret.Checks.GFF3 import CheckGFF
from piret.Checks.aligner import check_aligner
from piret.Checks.config import parse_config, check_input
from piret.logger import create_logger
from luigi.interface import build




def cmdline_parser():
    """
    Create an argparse instance.

    Combination of different options for this script.
    """
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                          argparse.RawDescriptionHelpFormatter):
        """For multiple formatters of argparse."""

        pass

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     prog='piret',
                                     description="""piret""",
                                     epilog="""
When selecting both kingdom runs, options that are required for both eukaryotes
and prokaryotes run are required.

Example run for Prokaryotes RNA seq:\n
        piret -d <workdir> -e <design file>  -gp <gff> -i <hisat2 index>
        -k prokarya -m <edgeR/DESeq2> -fp <FASTA>

Example run for Eukaryotes RNA seq:\n
        piret -d <workdir> -e <design file>  -ge <gff> -i <hisat2 index>
        -k eukarya -m <edgeR/DESeq2> -fe <FASTA>

Example run for Both (Eukaryotes and Prokaryotes) RNA seq:\n
        piret -d <workdir> -e <design file>  -gp <gff> -ge <gff>
        -i <hisat2 index> -k both -m <edgeR/DESeq2> -fe <FASTA> -fp <FASTA>
        """)

    # parser.add_argument("-c", dest="CPU", help="""number of threads. The parameter
    # is passed to threads parameter in QC, HISAT, STAR, etc.""",
    #                     required=False, default=1)

    required_args = parser.add_argument_group('required arguments')

    required_args.add_argument("-d", dest="WORKDIR", help="""working directory where all
        output files will be processed and written""", required=True)

    required_args.add_argument("-e", dest="EXPDSN", help="""tab delimited experimental
        design file""", required=True, default=argparse.SUPPRESS)

    required_args.add_argument("-c", "--config", help="""luigi config file for setting
        parameters that control each step, see github repo for an example""", required=True, default=None)

    required_prok_args = parser.add_argument_group("""required arguments
                                                      (for prokaryotes)""")

    required_prok_args.add_argument("-fp", dest="FASTA_PROK", help="""fasta for
        Prokaryotic Reference""", required=False, default=None)

    required_prok_args.add_argument("-gp", dest="GFF_PROK", help="""path to gff
        files for prokaryotic organism, must be a .gff file""", required=False,
                                    default=None)

    required_euk_args = parser.add_argument_group('required arguments (for eukaryotes)')

    required_euk_args.add_argument("-fe", dest="FASTA_EUK", help="""fasta for Eukaryotic Refe
        rence""", required=False, default=None)
    required_euk_args.add_argument("-ge", dest="GFF_EUK", help="""path to gff files for eukar
        yotic organism, must be a .gff file""", required=False, default=None)

    required_path_args = parser.add_argument_group('required arguments (for pathway and GAGE analysis)')

    required_path_args.add_argument("--pathway", dest="PATHWAY", help="""Generate Pathway heatmaps. Specifying --pathway turns this ON.""",
                        required=False, default=False, action="store_true")

    required_path_args.add_argument("--gage", dest="GAGE", help="""Perform GAGE analysis. Specifying --gage turns this ON.""",
                        required=False, default=False, action="store_true")

    parser.add_argument("-i", dest="INDEX_HISAT", help="""hisat2 index file, it only
        creates index if it does not exist""", required=False, default=None)

    parser.add_argument("-m", dest="METHOD", help="""Method to use for detecting
        differentially expressed genes, DESeq2 requires 3 biological replicates
        and ballgown only processes eukaryotes""", required=False,
                        default='DESeq2',
                        choices=['edgeR', 'DESeq2', 'ballgown', 'DEedge',
                                 'DEgown', 'balledgeR', 'all'])

    parser.add_argument("--star_db", dest="STARDB", help="""A folder to keep star formatted DB.""",
                        required=False)

    parser.add_argument("-p", dest="P_VALUE", help="""P-Value to consider ifs
        genes are significantly different, default is 0.001""",
                        required=False, default=0.001,
                        type=float)

    parser.add_argument("--scheduler", help="""when specified, will use luigi
        scheduler which allows you to keep track of task using an url
        specified through luigid""", required=False, default=True,
                        action='store_false')

    parser.add_argument("--qsub", help="""run the SGE version of the code, it
        currently is set to SGE with smp""", required=False,
                        action='store_true', default=False)

    parser.add_argument("--qc_off", dest="QC_OFF", help="""A flag indicating not to perform QC.""",
                        required=False, default=False, action="store_true")

    parser.add_argument("--novel", dest="NOVEL", help="""A flag indicating to find novel regions.""",
                        required=False, default=False, action="store_true")

    parser.add_argument('--version', action='version', version='%(prog)s 0.3.4')


    return parser


def main():
    """
    Main function.

    All functions are called here.
    """
    parser = cmdline_parser()
    args = parser.parse_args()

    os.environ["LUIGI_CONFIG_PATH"] = args.config

    # setting up logging files
    logger = create_logger(args.WORKDIR)

    # get parameters from the config file
    paras = parse_config(args.config)

    # check if correct options are selected
    check_input(paras, parser=parser)

    # check if required third party tools are in path
    if paras["aligner"] == "STAR":
        check_depen(["STAR", "samtools"], logger)
    elif paras["aligner"] == "hisat2":
        check_depen(["hisat2", "samtools"], logger)

    # getting absolute path of workdir
    workdir = os.path.abspath(args.WORKDIR)

    if check_exp_design(args.EXPDSN) is False:  # check if experimental design file is OK
        sys.exit("Your experimental design file has formatting problems!")

    # convert exerimental design file to a dictionary object
    samp_dic = CheckDesign(args.EXPDSN).extract_sample_fastqs()

    no_of_jobs = 1

    # assigns filenames for databases if not specified.
    db = check_aligner(aligner=paras["aligner"],
                       hisat_index=paras["hisat_index"],
                       workdir=workdir, star_db=paras["star_index"])

    # TODO move this to log file
    summarize_run(aligner=paras["aligner"])  # print run information in screen

    # assign universal fasta and gff variable
    if paras["kingdom"] in ["prokarya", "eukarya"]:
        if paras["kingdom"] == "prokarya":
            fasta = paras["fasta_prok"]
            gff = paras["gff_prok"]
        elif paras["kingdom"] == "eukarya":
            fasta = paras["fasta_euk"]
            gff = paras["gff_euk"]
        single_seq = SingleSeq(qc=paras["qc"],
                                fastq_dic=samp_dic,
                            aligner=paras["aligner"],
                            ref_fasta=fasta,
                            num_cpus=paras["threads"],
                            local_scheduler=args.scheduler,
                            hisat_index=db,
                            workdir=workdir,
                            kingdom=paras["kingdom"],
                            no_of_jobs=no_of_jobs,
                            p_value=paras["q_value"],
                            exp_desn_file=args.EXPDSN,
                            stardb_dir=db,
                            gff_file=gff,
                            pathway=paras["pathway"])

        # step 1, run qc
        qc_dic = single_seq.run_faqc()

        # step 2, create database, hisat2 or stardb
        single_seq.create_db()

        # step 3, map reads, hisat2 or stardb
        single_seq.map_reads(qc_dic=qc_dic)

        # step 4, summarize the mapped reads
        single_seq.map_summarize()

        # step 5, if needed
        if paras["novel"] is True:  # if novel regions are to be reported
            single_seq.extract_pp()  # extract properly paired reads
            single_seq.novel_regions()  # find novel regions
            single_seq.create_new_gff()  # create a new GFF file that has novel region info
            gff = os.path.join(workdir, "processes", "novel", "updated.gff")  # update gff

        # step 6, run read counts
        single_seq.feature_count()

        # run emapper
        single_seq.run_emapper()


        # find diff expressed gene using edgeR
        # if "edger" in paras["method"]:
            # single_seq.run_edger()
        # use DESeq2
        if "deseq2" in paras["method"]:
            single_seq.run_deseq2()
        elif "ballgown" in paras["method"]:
            single_seq.merge_stringtie()
            single_seq.restringtie(gff=gff)
            single_seq.run_ballgown(gff=gff)
        
        single_seq.summ_json()

    # if args.TEST_KINGDOM == 'both' and args.qsub is False:
    #     check_ref(ref_gff=args.GFF_EUK, ref_fasta=args.FASTA_EUK)
    #     check_ref(ref_gff=args.GFF_PROK, ref_fasta=args.FASTA_PROK)
    #     fastas = ",".join([args.FASTA_PROK, args.FASTA_EUK])
    #     gffs = ",".join([args.GFF_PROK, args.GFF_EUK])
    #     if check_method(args.METHOD, args.EXPDSN) is True:
    #         run_faqc(fastq_dic=samp_dic, num_cpus=args.CPU, workdir=workdir,
    #                  local_scheduler=args.scheduler)
    #     dual_seq = Workflows.DualSeq(fastq_dic=samp_dic, ref_fastas=fastas,
    #                                  aligner=args.ALIGNER,
    #                                  hisat_index=db,
    #                                  workdir=workdir,
    #                                  kingdom=args.TEST_KINGDOM,
    #                                  no_of_jobs=1,
    #                                  local_scheduler=args.scheduler,
    #                                  num_cpus=args.CPU,
    #                                  exp_desn_file=args.EXPDSN,
    #                                  p_value=args.P_VALUE,
    #                                  ref_gffs=gffs,  # gff of both,
    #                                  stardb_dir=db
    #                                  )

    #     dual_seq.create_db(gffs) # create database (star or hisat2 based on choice)
    #     dual_seq.map_reads()
    #     dual_seq.map_summarize()
    #     dual_seq.split_prokeuk()
    #     if args.NOVEL is True: # if novel regions are to be reported
    #         dual_seq.extract_pp() # extract properly paired reads
    #         dual_seq.novel_regions() # find novel regions
    #         dual_seq.create_new_gff() # create a new GFF file that has novel region info
    #         gffs = ",".join([os.path.join(workdir, "prok_updated.gff"), os.path.join(workdir, "euk_updated.gff")]) # update gff
    #     dual_seq.feature_counts()
    #     if args.METHOD == "edgeR":
    #         dual_seq.run_edger()
    #     elif args.METHOD == "DESeq2":
    #         dual_seq.run_deseq2()
    #     elif args.METHOD == "ballgown":
    #         dual_seq.merge_stringties()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "DEedge":
    #         dual_seq.run_edger()
    #         dual_seq.run_deseq2()
    #     elif args.METHOD == "DEgown":
    #         dual_seq.run_deseq2()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "balledgeR":
    #         dual_seq.run_edger()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()
    #     elif args.METHOD == "all":
    #         dual_seq.run_edger()
    #         dual_seq.run_deseq2()
    #         dual_seq.restringtie()
    #         dual_seq.run_ballgown()


def check_exp_design(exp_design_file):
    """A function that checks different aspects of experimental des. file.

    it returns True if all checked conditions are True. This is the first step
    of the pipeline.
    """
    exp_desn = CheckDesign(exp_design_file)
    if all([exp_desn.tab(),
            exp_desn.header(),
            exp_desn.sample_name(),
            exp_desn.file_name(),
            exp_desn.group_name(),
            exp_desn.sample_name(),
            exp_desn.fastq_exists()]) is True:
        return True


def check_gff(gff_file):
    """A function that checks gff file.

    it returns True if all checked conditions are True. This is one of
    the first stepof the pipeline.
    """
    gff = CheckGFF(gff_file)
    if all([gff.size(), gff.check_id(), gff.check_unique_id()]) is True:
        return True
    else:
        return False

def check_index_file(indexfile):
    """Check if index file is present."""
    hisat_file = indexfile + '.6.ht2l'
    if os.path.exists(hisat_file):
        return True
    else:
        return False


def check_star_aligner(method, kingdom):
    """Only allow STAR aligner to work for eukarya only."""
    if method in ('STAR') and kingdom == "prokarya":
        sys.exit("STAR does not work well for prokaryotic genomes, pick hisat2!")
    else:
        return True

def check_method(method, exp_design_file):
    """Based on chosen method, if enough samples are present."""
    exp_desn = CheckDesign(exp_design_file)
    if method in ('DESeq2', 'all', 'DEgown', 'DEedge') and exp_desn.sample_suff(method='Deseq'):
        return True
    elif method in ('edgeR', 'ballgown', 'balledgeR'):
        return True
    else:
        sys.exit("DESeq2 requires at least three replicates within a group!")


def check_ref(ref_fasta=None, ref_gff=None):
    """Check if references are present."""
    if ',' in ref_fasta:
        if all([os.path.exists(f) for f in ref_fasta.split(",")]) is True:
            pass
        else:
            sys.exit("One of the reference fasta do not exist!")
    if ',' in ref_gff:
        if all([os.path.exists(f) for f in ref_gff.split(",")]) is True:
            return True
        else:
            sys.exit("One of the reference gff do not exist!")
    else:
        if os.path.exists(ref_gff) and os.path.exists(ref_fasta):
            if check_gff(ref_gff) is True:
                return True
        else:
            if os.path.exists(ref_fasta) is False:
                exit_message = ' '.join(("Reference FASTA", ref_fasta, "does not exist!"))
                sys.exit(exit_message)
            elif os.path.exists(ref_gff) is False:
                exit_message = ' '.join(("Reference GFF", ref_gff, "does not exist!"))


def summarize_run(aligner):
    """Prints summary information of runs."""
    print("Alignment will be done using: %s" %aligner)


if __name__ == '__main__':
    main()
