#!/usr/bin/env python

"""
RNA seq pipeline.

wrapper for running RNASeq pipeline

"""

from __future__ import print_function
import os
import sys
import argparse
dir_path = os.path.dirname(os.path.realpath(__file__))
lib_path = os.path.abspath(os.path.join(dir_path, '..'))
bin_path = os.path.join(lib_path, 'bin')
sys.path.append(lib_path)
os.environ["PATH"] += os.pathsep + bin_path
from pypiret import CheckDesign, FaQC, Map, Summ, DGE, srna
from pypiret.Checks.GFF3 import CheckGFF
from luigi.interface import build
import luigi


def cmdline_parser():
    """
    Create an argparse instance.

    Combination of different options for this script.
    """
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                          argparse.RawDescriptionHelpFormatter):
        """For multiple formatters of argparse."""

        pass

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     prog='runPiReT',
                                     description="""RNASeq workflow""",
                                     epilog="""
When selecting both kingodm runs, options that are required for both eukaryotes
and prokaryotes run are required.

Example run for Prokaryotes RNA seq:\n
        runPiReT -d <workdir> -e <design file>  -gp <gff> -i <hisat2 index>
        -k prokarya -m <edgeR/DESeq2> -fp <FASTA>

Example run for Eukaryotes RNA seq:\n
        runPiReT -d <workdir> -e <design file>  -ge <gff> -i <hisat2 index>
        -k eukarya -m <edgeR/DESeq2> -fe <FASTA>

Example run for Both (Eukaryotes and Prokaryotes) RNA seq:\n
        runPiReT -d <workdir> -e <design file>  -gp <gff> -ge <gff>
        -i <hisat2 index> -k both -m <edgeR/DESeq2> -fe <FASTA> -fp <FASTA>
        """)

    parser.add_argument("-c", dest="CPU", help="""number of CPUs/threads to
        run per task. Here, task refers to a processing step.For example,
        number of CPUs specified here will be used for QC, HISAT index and
        mapping steps. Since QC and mapping steps are run for every sample,
        be aware that the total number of CPUs needed are your number of
        samples times CPU specified here.""",
                        required=False, default=1)

    required_args = parser.add_argument_group('required arguments')

    required_args.add_argument("-d", dest="WORKDIR", help="""working directory where all
        output files will be processed and written""", required=True)

    required_args.add_argument("-e", dest="EXPDSN", help="""tab delimited experimental
        design file""", required=True, default=argparse.SUPPRESS)

    required_prok_args = parser.add_argument_group('required arguments (for prokaryotes)')

    required_prok_args.add_argument("-fp", dest="FASTA_PROK", help="""fasta for
        Prokaryotic Reference""", required=False, default=None)

    required_prok_args.add_argument("-gp", dest="GFF_PROK", help="""path to gff
        files for prokaryotic organism, must be a .gff file""", required=False,
                                    default="")

    required_euk_args = parser.add_argument_group('required arguments (for eukaryotes)')

    required_euk_args.add_argument("-fe", dest="FASTA_EUK", help="""fasta for Eukaryotic Refe
        rence""", required=False, default=None)
    required_euk_args.add_argument("-ge", dest="GFF_EUK", help="""path to gff files for eukar
        yotic organism, must be a .gff file""", required=False, default="")

    parser.add_argument("-i", dest="INDEX_HISAT", help="""hisat2 index file, it only
        creates index if it does not exist""", required=False, default=None)

    parser.add_argument("--config", help="""config file for setting
        parameters that control each step""", required=False, default=None)

    parser.add_argument("-k", dest="TEST_KINGDOM", help="""which kingdom to test,
        when eukarya or both is chosen, it expects alternative splicing""",
                        required=False, default='prokarya',
                        choices=['prokarya', 'eukarya', 'both'])

    parser.add_argument("-m", dest="METHOD", help="""Method to use for detecting
        differentially expressed genes, DESeq2 requires 3 biological replicates
        and ballgown only processes eukaryotes""", required=False,
                        default='balledgeR',
                        choices=['edgeR', 'DESeq2', 'ballgown', 'DEedge',
                                 'DEgown', 'balledgeR', 'all'])

    parser.add_argument("-p", dest="P_VALUE", help="""P-Value to consider ifs
        genes are significantly different, default is 0.001""",
                        required=False, default=0.001,
                        type=float)

    parser.add_argument("--scheduler", help="""when specified, will use luigi
        scheduler which allows you to keep track of task using an url
        specified through luigid""", required=False, default=True,
                        action='store_false')

    parser.add_argument("--qsub", help="""run the SGE version of the code, it
        currently is set to SGE with smp""", required=False,
                        action='store_true', default=False)

    parser.add_argument('--version', action='version', version='%(prog)s 0.3')

    return parser


def main():
    """
    Main function.

    All functions are called here.
    """
    parser = cmdline_parser()
    args = parser.parse_args()

    # Getting absolute path of some directories
    workdir = os.path.abspath(args.WORKDIR)
    bindir = os.path.abspath(os.path.join(dir_path, '..', 'bin'))
    os.environ['PATH'] = os.environ['PATH'] + ":" + bindir
    if check_exp_design(args.EXPDSN) is True:
        no_of_jobs = 1
        samp_dic = CheckDesign(args.EXPDSN).extract_sample_fastqs()
        if check_method(args.METHOD, args.EXPDSN) is True:
            run_faqc(fastq_dic=samp_dic, num_cpus=args.CPU, workdir=workdir,
                     local_scheduler=args.scheduler)
        if args.INDEX_HISAT is None:
                hisat_index_name = os.path.join(workdir, "hisat_index")
        else:
            hisat_index_name = args.INDEX_HISAT
            if args.TEST_KINGDOM == 'prokarya' and args.qsub is False:
                check_ref(ref_gff=args.GFF_PROK, ref_fasta=args.FASTA_PROK)
                euk_prok(ref_fasta=args.FASTA_PROK,
                         ref_gff=args.GFF_PROK,
                         hisat_index=hisat_index_name,
                         bindir=bindir,
                         num_cpus=args.CPU,
                         local_scheduler=args.scheduler,
                         fastq_dic=samp_dic,
                         workdir=workdir,
                         kingdom=args.TEST_KINGDOM,
                         exp_desn_file=args.EXPDSN,
                         p_value=args.P_VALUE)
            elif args.TEST_KINGDOM == 'eukarya' and args.qsub is False:
                check_ref(ref_gff=args.GFF_EUK, ref_fasta=args.FASTA_EUK)
                euk_prok(ref_fasta=args.FASTA_EUK,
                         ref_gff=args.GFF_EUK,
                         hisat_index=hisat_index_name,
                         bindir=bindir,
                         num_cpus=args.CPU,
                         local_scheduler=args.scheduler,
                         fastq_dic=samp_dic,
                         workdir=workdir,
                         kingdom=args.TEST_KINGDOM,
                         exp_desn_file=args.EXPDSN,
                         p_value=args.P_VALUE)
            elif args.TEST_KINGDOM == 'both' and args.qsub is False:
                check_ref(ref_gff=args.GFF_EUK, ref_fasta=args.FASTA_EUK)
                check_ref(ref_gff=args.GFF_PROK, ref_fasta=args.FASTA_PROK)
                fastas = ",".join([args.FASTA_PROK, args.FASTA_EUK])
                gffs = ",".join([args.GFF_PROK, args.GFF_EUK])
                dual_seq(fastq_dic=samp_dic, fastas=fastas,
                         gffs=gffs, hisat_index=hisat_index_name,
                         local_scheduler=args.scheduler,
                         num_cpus=args.CPU, workdir=workdir,
                         exp_desn_file=args.EXPDSN, p_value=args.P_VALUE,
                         bindir=bindir)


def build_index(ref_fasta, hisat_index, bindir, num_cpus, local_scheduler):
    """ build HiSat index"""
    build([Map.HisatIndex(fasta=ref_fasta, hi_index=hisat_index,
                          bindir=bindir, num_cpus=num_cpus)],
          local_scheduler=local_scheduler)

def euk_prok(ref_fasta, hisat_index, bindir, num_cpus,
             local_scheduler, fastq_dic, workdir, ref_gff,
             kingdom, exp_desn_file, p_value):
    """All pipelines."""
    no_of_jobs = 1
    build([Map.HisatIndex(fasta=ref_fasta, hi_index=hisat_index,
                          num_cpus=num_cpus),
           Map.GFF2GTF(gff_file=ref_gff, workdir=workdir)],
          local_scheduler=local_scheduler)
    if kingdom == "eukarya":
        build([Map.CreateSplice(gff_file=ref_gff, bindir=bindir,
                                workdir=workdir)],
              local_scheduler=local_scheduler)

    # Map reads to Hisat index
    build([srna.SummarizeMap(fastq_dic=fastq_dic, num_cpus=num_cpus,
                             indexfile=hisat_index,
                             workdir=workdir, ref_file=ref_fasta,
                             kingdom=kingdom)],
          local_scheduler=local_scheduler, workers=no_of_jobs)
    build([srna.FindNovelRegionsW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                                  indexfile=hisat_index, kingdom=kingdom,
                                  workdir=workdir, ref_file=ref_fasta,
                                  gff_file=ref_gff)],
          local_scheduler=local_scheduler, workers=no_of_jobs)
    build([srna.CompileGFF(fastq_dic=fastq_dic, num_cpus=num_cpus,
                           indexfile=hisat_index, kingdom=kingdom,
                           workdir=workdir, ref_file=ref_fasta, gff_file=ref_gff)],
          local_scheduler=local_scheduler, workers=no_of_jobs)

    # Stringtie
    build([Map.StringTieScoresW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                                indexfile=hisat_index,
                                workdir=workdir, ref_file=ref_fasta,
                                gff_file=os.path.join(workdir, "updated.gff"),
                                kingdom=kingdom)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)
    # # FeatureCounts
    build([Summ.FeatureCounts(fastq_dic=fastq_dic, num_cpus=num_cpus,
                              gff=os.path.join(workdir, "updated.gff"),
                              indexfile=hisat_index, kingdom=kingdom,
                              workdir=workdir,
                              ref_file=ref_fasta),
          Summ.MergeStringTies(fastq_dic=fastq_dic,
                                                num_cpus=num_cpus,
                                                indexfile=hisat_index,
                                                workdir=workdir,
                                                ref_file=ref_fasta,
                                                gff_file=os.path.join(workdir, "updated.gff"),
                                                kingdom=kingdom)],
                          local_scheduler=local_scheduler, workers=1)
    # Merge
    build([Summ.ReStringTieScoresW(fastq_dic=fastq_dic,
                                                   num_cpus=num_cpus,
                                                   indexfile=hisat_index,
                                                   workdir=workdir,
                                                   ref_file=ref_fasta,
                                                   gff_file=os.path.join(workdir, "updated.gff"),
                                                   kingdom=kingdom)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)
    # diff seq
    build([DGE.edgeR(fastq_dic=fastq_dic,
                                     num_cpus=num_cpus,
                                     indexfile=hisat_index,
                                     bindir=bindir,
                                     workdir=workdir,
                                     ref_file=ref_fasta,
                                     kingdom=kingdom,
                                     gff=os.path.join(workdir, "updated.gff"),
                                     exp_design=exp_desn_file,
                                     p_value=p_value),
                           DGE.DESeq2(fastq_dic=fastq_dic,
                                      num_cpus=num_cpus,
                                      indexfile=hisat_index,
                                      bindir=bindir,
                                      workdir=workdir,
                                      ref_file=ref_fasta,
                                      kingdom=kingdom,
                                      gff=os.path.join(workdir, "updated.gff"),
                                      exp_design=exp_desn_file,
                                      p_value=p_value)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)


def dual_seq(fastq_dic, fastas, gffs, hisat_index,
             local_scheduler, workdir,num_cpus,
             exp_desn_file, p_value, bindir):
    no_of_jobs = 1 
    build([Map.HisatIndex(fasta=fastas, hi_index=hisat_index,
                          num_cpus=num_cpus),
           Map.SAMindex(fasta=fastas, workdir=workdir),
           Map.CreateSplice(gff_file=gffs.split(",")[1],
                            workdir=workdir),
           Map.GetChromName(prok_ref=fastas.split(",")[0],
                            euk_ref=fastas.split(",")[1],
                            workdir=workdir)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)
    build([Map.HisatMapW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                             indexfile=hisat_index, workdir=workdir,
                             ref_file=fastas)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)
    build([Map.Split2ProkEukW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                              indexfile=hisat_index,
                              workdir=workdir, ref_file=fastas)],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)

    build([srna.SummarizeMap(fastq_dic=fastq_dic, num_cpus=num_cpus,
                             indexfile=hisat_index, workdir=workdir,
                             ref_file=fastas, kingdom="both")],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)


    build([srna.FindNovelRegionsW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                                  indexfile=hisat_index, workdir=workdir,
                                  ref_file=fastas, gff_file=gffs,
                                  kingdom="both")],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)
    build([srna.CompileGFF(fastq_dic=fastq_dic, num_cpus=num_cpus,
                           indexfile=hisat_index, kingdom="both",
                           workdir=workdir, ref_file=fastas, gff_file=gffs)],
          local_scheduler=local_scheduler, workers=no_of_jobs)

    build([Map.StringTieScoresW(fastq_dic=fastq_dic, num_cpus=num_cpus,
                               indexfile=hisat_index,
                               gff_file=",".join([os.path.join(workdir, "prok_updated.gff"),
                                                  os.path.join(workdir, "euk_updated.gff")]),
                               kingdom='both',
                               workdir=workdir,
                               ref_file=fastas),
          Summ.FeatureCounts(fastq_dic=fastq_dic,
                             num_cpus=num_cpus,
                             gff=os.path.join(workdir, "prok_updated.gff"),
                             indexfile=hisat_index,
                             kingdom='prokarya',
                             workdir=workdir,
                             ref_file=fastas.split(",")[0]),
          Summ.FeatureCounts(fastq_dic=fastq_dic,
                             num_cpus=num_cpus,
                             gff=os.path.join(workdir, "euk_updated.gff"),
                             indexfile=hisat_index,
                             kingdom='eukarya',
                             workdir=workdir,
                             ref_file=fastas.split(",")[1]),
          DGE.edgeR(fastq_dic=fastq_dic,
                   num_cpus=num_cpus,
                   indexfile=hisat_index,
                   workdir=workdir,
                   ref_file=fastas.split(",")[0],
                   kingdom='prokarya',
                   gff=os.path.join(workdir, "prok_updated.gff"),
                   exp_design=exp_desn_file,
                   bindir=bindir,
                   p_value=p_value),
          DGE.edgeR(fastq_dic=fastq_dic,num_cpus=num_cpus,
                                     indexfile=hisat_index,
                                     bindir=bindir,
                                     workdir=workdir,
                                     ref_file=fastas.split(",")[1],
                                     kingdom='eukarya',
                                     gff=os.path.join(workdir, "euk_updated.gff"),
                                     exp_design=exp_desn_file,
                                     p_value=p_value),
                           DGE.DESeq2(fastq_dic=fastq_dic,
                                      num_cpus=num_cpus,
                                      indexfile=hisat_index,
                                      bindir=bindir,
                                      workdir=workdir,
                                      ref_file=fastas.split(",")[0],
                                      kingdom='prokarya',
                                      gff=os.path.join(workdir, "prok_updated.gff"),
                                      exp_design=exp_desn_file,
                                      p_value=p_value),
                           DGE.DESeq2(fastq_dic=fastq_dic,
                                      num_cpus=num_cpus,
                                      indexfile=hisat_index,
                                      bindir=bindir,
                                      workdir=workdir,
                                      ref_file=fastas.split(",")[1],
                                      kingdom='eukarya',
                                      gff=os.path.join(workdir, "euk_updated.gff"),
                                      exp_design=exp_desn_file,
                                      p_value=p_value)
                           ],
                          local_scheduler=local_scheduler,
                          workers=no_of_jobs)


def run_faqc(fastq_dic, num_cpus, workdir, local_scheduler):
    """A function that calls the FaQC function.

    it returns QCed files in respective directory
    """
    build([FaQC.SummarizeQC(fastq_dic=fastq_dic,
                              num_cpus=num_cpus,
                              workdir=workdir)],
          local_scheduler=local_scheduler,
          workers=1)



def check_exp_design(exp_design_file):
    """A function that checks different aspects of experimental des. file.

    it returns True if all checked conditions are True. This is the first step
    of the pipeline.
    """
    exp_desn = CheckDesign(exp_design_file)
    if all([exp_desn.tab(),
            exp_desn.header(),
            exp_desn.sample_name(),
            exp_desn.file_name(),
            exp_desn.group_name(),
            exp_desn.sample_name(),
            exp_desn.fastq_exists()]) is True:
        return True


def check_gff(gff_file):
    """A function that checks gff file.

    it returns True if all checked conditions are True. This is one of 
    the first stepof the pipeline.
    """
    gff = CheckGFF(gff_file)
    if all([gff.size(), gff.check_id(), gff.check_unique_id()]) is True:
        return True

def check_index_file(indexfile):
    """Check if index file is present."""
    hisat_file = indexfile + '.6.ht2l'
    if os.path.exists(hisat_file):
        return True
    else:
        return False


def check_method(method, exp_design_file):
    """Based on chosen method, if enough samples are present."""
    exp_desn = CheckDesign(exp_design_file)
    if method in ('DESeq2', 'all', 'DEgown', 'DEedge') and exp_desn.sample_suff(method='Deseq'):
        return True
    elif method in ('edgeR', 'ballgown', 'balledgeR'):
        return True
    else:
        sys.exit("DESeq2 requires at least three replicates within a group!")


def check_ref(ref_fasta=None, ref_gff=None):
    """Check if references are present."""
    if ',' in ref_fasta:
        if all([os.path.exists(f) for f in ref_fasta.split(",")]) is True:
            pass
        else:
            sys.exit("One of the reference fasta do not exist!")
    if ',' in ref_gff:
        if all([os.path.exists(f) for f in ref_gff.split(",")]) is True:
            return True
        else:
            sys.exit("One of the reference gff do not exist!")
    else:
        if os.path.exists(ref_gff) and os.path.exists(ref_fasta):
            if check_gff(ref_gff) is True:
                return True
        else:
            if os.path.exists(ref_fasta) is False:
                exit_message = ' '.join(("Reference FASTA", ref_fasta, "does not exist!"))
                sys.exit(exit_message)
            elif os.path.exist(ref_gff) is False:
                exit_message = ' '.join(("Reference GFF", ref_gff, "does not exist!"))



if __name__ == '__main__':
    main()
